package robb.ai;

public class SEE {
	
	private static int see(Board board, byte targetSquare, byte enemy, long emptyMask){
//		long targetMask = (1L << targetSquare);
		byte bestCapture = (byte)getBestCapture(board, targetSquare, emptyMask);		
		int value = 0;
		
		if(bestCapture != -1){
			if(enemy == 5 || enemy == 11) return Engine.mateValue;
			byte piece = Utils.getPieceAt(board, bestCapture);	
			board.whiteToMove = !board.whiteToMove;
			value = Math.max(0, Math.abs(Evaluation.score[enemy]) - see(board, targetSquare, piece, emptyMask | (1L << bestCapture)));
			board.whiteToMove = !board.whiteToMove;
	   }
		
	   return value;
	}
	
	public static int seeCapture(Board board, short move){
		byte piece = Utils.getPieceAt(board, NewMoveStructure.getFrom(move));
		byte end = NewMoveStructure.getTo(move);
		byte enemy = Utils.getPieceAt(board, end);
		
		if(piece == 12) return 0;
		if(enemy == 5 || enemy == 11) return Engine.mateValue;
		
		board.whiteToMove = !board.whiteToMove;
		int value = Math.abs(Evaluation.score[enemy]) - see(board, end, piece, (1L << NewMoveStructure.getFrom(move)));
		board.whiteToMove = !board.whiteToMove;
		return value;
	}
	
	/**
	 * This looks for the lowest value capturer by looking at the opponent's moves, and seeing whether they match-up with the corresponding piece,
	 * hence why the use of most methods seem backwards in their "friendly" and "enemy" pieces
	 */
	private static int getBestCapture(Board b, byte targetSquare, long emptyMask){
//		long targetMask = (1L << targetSquare);
		long notEmpty = ~emptyMask;
		
		//Pawn moves
		long piecesToVisit = (b.whiteToMove ? b.WP : b.BP) & notEmpty & MoveGeneration.pawnAttackMasks[b.whiteToMove ? 1 : 0][targetSquare];
		if(piecesToVisit != 0) return Long.numberOfTrailingZeros(piecesToVisit);
		
		//Knight moves
		piecesToVisit = (b.whiteToMove ? b.WN : b.BN) & notEmpty & MoveGeneration.knightMoves[targetSquare];
		if(piecesToVisit != 0) return Long.numberOfTrailingZeros(piecesToVisit);
		
		//Mask the pieces and moves for handling the sliding piece moves
		long friendlyPieces = b.whiteToMove ? (b.WP | b.WN | b.WB | b.WR | b.WQ | b.WK) : (b.BP | b.BN | b.BB | b.BR | b.BQ | b.BK);
		long enemyPieces = b.whiteToMove ? (b.BP | b.BN | b.BB | b.BR | b.BQ | b.BK) : (b.WP | b.WN | b.WB | b.WR | b.WQ | b.WK);
//		long bishopMoves = (MoveGeneration.northEastMoves[targetSquare] | MoveGeneration.southEastMoves[targetSquare] | MoveGeneration.southWestMoves[targetSquare] | MoveGeneration.northWestMoves[targetSquare]);
//		long rookMoves = (MoveGeneration.northMoves[targetSquare] | MoveGeneration.eastMoves[targetSquare] | MoveGeneration.southMoves[targetSquare] | MoveGeneration.westMoves[targetSquare]);
		long bishopMoves = MoveGeneration.getAllBishopMoves(targetSquare, friendlyPieces, enemyPieces, emptyMask);
		long rookMoves = MoveGeneration.getAllRookMoves(targetSquare, friendlyPieces, enemyPieces, emptyMask);
		
		//Bishop moves
		piecesToVisit = (b.whiteToMove ? b.WB : b.BB) & notEmpty & bishopMoves;
		if(piecesToVisit != 0) return Long.numberOfTrailingZeros(piecesToVisit);
		
		//Rook moves
		piecesToVisit = (b.whiteToMove ? b.WR : b.BR) & notEmpty & rookMoves;
		if(piecesToVisit != 0) return Long.numberOfTrailingZeros(piecesToVisit);
		
		//Queen moves
		piecesToVisit = (b.whiteToMove ? b.WQ : b.BQ) & notEmpty & (bishopMoves | rookMoves);
		if(piecesToVisit != 0) return Long.numberOfTrailingZeros(piecesToVisit);
		
		//King moves
		piecesToVisit = (b.whiteToMove ? b.WK : b.BK) & notEmpty & MoveGeneration.kingMoves[targetSquare];
		if(piecesToVisit != 0) return Long.numberOfTrailingZeros(piecesToVisit);
		
		return -1;
	}

}
